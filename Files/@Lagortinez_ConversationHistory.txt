[{'role': 'user', 'content': 'With the given code, could you add a checker for the startGPTCall function, so if the response is taking longer, the typing... send chat action can last until the reply is ready? CODE: import asyncio\nimport logging\nimport os\n\nfrom aiogram import Bot, Dispatcher, types\nfrom aiogram.types import ParseMode\n\nimport openai \n\nasync def startChatGPTCall(prompt: str, conversationHistory: list = []):\n    message = []\n    for element in conversationHistory:\n        message.append(element)\n    message.append({"role": "user", "content": prompt})\n    completion = openai.ChatCompletion.create(\n        model="gpt-3.5-turbo",\n        messages=message\n    )\n\n    result = \'\'\n    for choice in completion.choices:\n        result += choice.message.content\n\n    message.append({"role": "bot", "content": result})\n    return result, message, completion.usage.total_tokens\n\nAPI_TOKEN = "6145822445:AAEBajHikY5YPo8BgcFyxyYBLFDovsPBSxg"\n\nif not API_TOKEN:\n    logging.error("TELEGRAM_BOT_API_TOKEN not provided!")\n    exit(1)\n\nbot = Bot(token=API_TOKEN, parse_mode=ParseMode.HTML)\ndp = Dispatcher(bot)\n\n\n@dp.message_handler(commands=[\'start\'])\nasync def send_welcome(message: types.Message):\n    await message.answer("Hi there! I am a chat bot. Please send me a message and I\'ll try to respond.")\n\n\n@dp.message_handler()\nasync def echo_message(message: types.Message):\n    chat_id = message.chat.id\n    text = message.text\n\n    # show typing\n    await bot.send_chat_action(chat_id, \'typing\')\n\n    # call GPT-3\n    result, _, _ = await startChatGPTCall(text)\n\n    # send response\n    await bot.send_message(chat_id, result)\n\n\nif name == \'main\':\n    logging.basicConfig(level=logging.INFO)\n    openai.api_key = "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"\n    asyncio.run(dp.start_polling())'}, {'role': 'assistant', 'content': '\n\nYou can add a timeout parameter to the startGPTCall function and use it to check if the response is taking longer than expected. Then, you can use the asyncio.wait_for function to wait for a response with a timeout. Here\'s an updated version of the code with the checker:\n\nimport asyncio\nimport logging\nimport os\nfrom typing import List\n\nfrom aiogram import Bot, Dispatcher, types\nfrom aiogram.types import ParseMode\n\nimport openai \n\nasync def startChatGPTCall(prompt: str, conversationHistory: List = [], timeout: int = 10):\n    message = []\n    for element in conversationHistory:\n        message.append(element)\n    message.append({"role": "user", "content": prompt})\n    completion = openai.ChatCompletion.create(\n        model="gpt-3.5-turbo",\n        messages=message\n    )\n\n    try:\n        result = await asyncio.wait_for(get_result(completion), timeout=timeout)\n    except asyncio.TimeoutError:\n        result = "Sorry, the response is taking longer than expected."\n    \n    message.append({"role": "bot", "content": result})\n    return result, message, completion.usage.total_tokens\n\nasync def get_result(completion):\n    result = \'\'\n    for choice in completion.choices:\n        result += choice.message.content\n    return result\n\nAPI_TOKEN = "6145822445:AAEBajHikY5YPo8BgcFyxyYBLFDovsPBSxg"\n\nif not API_TOKEN:\n    logging.error("TELEGRAM_BOT_API_TOKEN not provided!")\n    exit(1)\n\nbot = Bot(token=API_TOKEN, parse_mode=ParseMode.HTML)\ndp = Dispatcher(bot)\n\n\n@dp.message_handler(commands=[\'start\'])\nasync def send_welcome(message: types.Message):\n    await message.answer("Hi there! I am a chat bot. Please send me a message and I\'ll try to respond.")\n\n\n@dp.message_handler()\nasync def echo_message(message: types.Message):\n    chat_id = message.chat.id\n    text = message.text\n\n    # show typing\n    await bot.send_chat_action(chat_id, \'typing\')\n\n    # call GPT-3\n    result, _, _ = await startChatGPTCall(text, timeout=10)\n\n    # send response\n    await bot.send_message(chat_id, result)\n\n\nif name == \'main\':\n    logging.basicConfig(level=logging.INFO)\n    openai.api_key = "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"\n    asyncio.run(dp.start_polling())'}]